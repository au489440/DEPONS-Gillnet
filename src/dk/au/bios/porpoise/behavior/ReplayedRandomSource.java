/*
 * Copyright (C) 2017-2019 Jacob Nabe-Nielsen <jnn@bios.au.dk>
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
 * License version 2 and only version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program; if not, see 
 * <https://www.gnu.org/licenses>.
 * 
 * Linking DEPONS statically or dynamically with other modules is making a combined work based on DEPONS. 
 * Thus, the terms and conditions of the GNU General Public License cover the whole combination.
 * 
 * In addition, as a special exception, the copyright holders of DEPONS give you permission to combine DEPONS 
 * with free software programs or libraries that are released under the GNU LGPL and with code included in the 
 * standard release of Repast Simphony under the Repast Suite License (or modified versions of such code, with unchanged license). 
 * You may copy and distribute such a system following the terms of the GNU GPL for DEPONS and the licenses of the 
 * other code concerned.
 * 
 * Note that people who make modified versions of DEPONS are not obligated to grant this special exception for 
 * their modified versions; it is their choice whether to do so. 
 * The GNU General Public License gives permission to release a modified version without this exception; 
 * this exception also makes it possible to release a modified version which carries forward this exception.
 */

package dk.au.bios.porpoise.behavior;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

import repast.simphony.space.continuous.NdPoint;

/**
 * Implementation of RandomSource which takes "random" numbers from a "replay file". A replay file contains among other
 * things, the random numbers generated by a simulation.
 */
public class ReplayedRandomSource implements RandomSource {

	// Behold my very slow and memory abusive implementation
	private final HashMap<String, Queue<String>> input = new HashMap<String, Queue<String>>();

	public ReplayedRandomSource(final String inputFile) {
		try {
			loadData(inputFile);
		} catch (final IOException ioe) {
			throw new RuntimeException(ioe);
		}

	}

	private void loadData(final String inputFile) throws IOException {
		final FileReader freader = new FileReader(inputFile);
		final BufferedReader reader = new BufferedReader(freader);

		String line;
		while ((line = reader.readLine()) != null) {
			final String[] parts = line.split(":");

			// The input should be in form <key>:<value>
			// The input might have more noise so we only read what we like
			if (parts.length == 2) {
				Queue<String> q = input.get(parts[0]);
				if (q == null) {
					q = new LinkedList<String>();
					input.put(parts[0], q);
				}

				q.add(parts[1]);
			}
		}

		reader.close();
	}

	private String getNextValue(final String key) {
		final Queue<String> q = input.get(key);
		if (q != null) {
			try {
				final String v = q.remove();

				// System.out.println("Replayed: " + key + ":" + v);

				return v;
			} catch (final java.util.NoSuchElementException e) {
				throw new RuntimeException("No value available for:" + key);
			}
		} else {
			throw new RuntimeException("No values exists for <" + key + ">");
		}
	}

	@Override
	public double nextEnergeticUpdate(final double from, final double to) {
		return Double.parseDouble(getNextValue("porp-upd-energetic-status"));
	}

	@Override
	public double nextMortality(final double from, final double to) {
		return Double.parseDouble(getNextValue("porp-upd-mortality"));
	}

	@Override
	public double nextPregnancyStatusConceive(final double from, final double to) {
		return Double.parseDouble(getNextValue("porp-upd-pregnancy-status-1"));
	}

	@Override
	public double nextPregnancyStatusBoyGirl(final double from, final double to) {
		return Double.parseDouble(getNextValue("porp-upd-pregnancy-status-2"));
	}

	@Override
	public int nextAvoidLand(final int from, final int to) {
		return Integer.parseInt(getNextValue("porp-avoid-land"));
	}

	@Override
	public int nextDisp3(final int from, final int to) {
		throw new RuntimeException("Not implemented");
	}

	@Override
	public int nextDispTargetSelect(final int from, final int to) {
		return Integer.parseInt(getNextValue("porp-disp-target-select"));
	}

	@Override
	public int nextStdMove(final int from, final int to) {
		return Integer.parseInt(getNextValue("porp-std-move"));
	}

	@Override
	public int nextAgeDistrib(final int from, final int to) {
		return Integer.parseInt(getNextValue("age-random"));
	}

	@Override
	public double nextEnergyNormal() {
		return Double.parseDouble(getNextValue("energy-normal"));
	}

	@Override
	public double nextMatingDayNormal() {
		return Double.parseDouble(getNextValue("mating-day"));
	}

	@Override
	public double nextCrwAngle() {
		return Double.parseDouble(getNextValue("normal-0-38"));
	}

	@Override
	public double nextCrwStepLength() {
		return Double.parseDouble(getNextValue("normal-042-048"));
	}

	@Override
	public double nextCrwAngleWithM() {
		return Double.parseDouble(getNextValue("normal-96-28"));
	}

	@Override
	public int pastLoc(final String id, final int max) {
		return Integer.parseInt(getNextValue(id + "-past-loc"));
	}

	@Override
	public NdPoint getInitialPoint() {
		final String point = getNextValue("initial");

		final String[] points = point.split(";");

		final double x = Double.parseDouble(points[0]);
		final double y = Double.parseDouble(points[1]);

		return new NdPoint(x, y);
	}

	@Override
	public Double getInitialHeading() {
		return Double.parseDouble(getNextValue("initial-heading"));
	}

	@Override
	public double nextPSMDistanceStddev() {
		throw new RuntimeException("Not implemented");
	}

	@Override
	public double nextDouble() {
		throw new RuntimeException("Not implemented");
	}

	@Override
	public int randomInt(final int from, final int to) {
		throw new RuntimeException("Not implemented");
	}

	@Override
	public int getInitialDaysSinceMating() {
		throw new RuntimeException("Not implemented");
	}

	@Override
	public double randomPlusMinusOne() {
		throw new RuntimeException("Not implemented");
	}

}
